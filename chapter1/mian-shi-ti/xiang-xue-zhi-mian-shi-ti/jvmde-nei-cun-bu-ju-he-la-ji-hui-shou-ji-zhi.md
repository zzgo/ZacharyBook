## Jvm内存模型

![](/assets/787812hjsaj.png)

包含：方法区，虚拟机栈，本地方法栈，堆，程序计数器

执行引擎，本地库接口

程序计数器：记录行号，用来知道下一次执行哪一行代码等

虚拟器栈，

把方法A打包栈帧放到虚拟机栈，b方法打包栈帧，直到b方法执行完毕后，a方法开始执行。也就是：

Java虚拟机栈：每个方法在被调用时就会创建一个栈帧，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程

Java堆：是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，对象实例在这里分配内存。是垃圾收集器（GC）管理的主要区域

方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，运行时常量池（Runtime Constant Pool）是方法区的一部分（Jdk1.6及以前 还包括运行时常量）。

直接内存：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域![](/assets/891298921jjaas.png) 

## 垃圾回收机制

#### 标记-清除算法（Mark-Sweep）

![](/assets/12347981hjdahj.png)

要回收的地方进行标记，要回收了，我就把标记位置进行统一的清除，

造成的内存碎片和内存不完整，容易造成没有连续的空间存储一个8K\(比如8K的数据\)

#### 复制算法

![](/assets/21398hahj00.png)

分成两边，左边放对象时，右边进行空余，左边内存不足了，要回收了，将左边存活的对象依次移动到右边，按次序摆好，这样右边比较规整，然后把左边的数据全部回收了，缺点是在任意的时间内都有一半的内存没有使用到，造成了内存的浪费

#### 标记-整理算法

![](/assets/2134789ahfjahjf.png)

要回收之前，将要回收的内存区域进行标记，实际要回收了，将存活的区域进行移动，按照某种规则，在内存中依次排好，然后回收掉回收的区域，这样的话内存比较规整，缺点，存在内存区域块进行移动，对性能有一定影响。

分代收集（把算法都用上）

新生代，采用复制算法；活过一定的次数，成为了老年代，采用标记-清除或者标记-整理（不同的垃圾回收器选择不同的算法）

垃圾回收器，单个，串行，多个垃圾回收器，并行

最近的jdk版本中，G1，他也有新生代和老年代

区别：

早期，内存区域是从逻辑上分为新生代和老年代

G1分成一个个小块，即可能给新生代（复制算法）用，也可能给老年代（标记整理）用

具体的算法就只有这几种，标记-清除，标记-整理，复制算法。

G1在性能上有一定的提升。





