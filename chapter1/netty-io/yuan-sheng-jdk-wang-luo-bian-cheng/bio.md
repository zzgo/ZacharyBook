### 阐述

服务端提供IP和监听端口，客户端通过连接操作向服务器监听的地址发起连接请求，通过三次握手，如果连接成功建立，双方就可以通过套接字进行通信。

传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口，Socket负责发起连接操作，连接成功后，双方通过输入和输出流进行同步阻塞式通信。

### 模型

采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的链接，它接收到客户端连接请求后为每个客户端创建一个新的线程进行处理，通过输出流返回应答给客户端，线程销毁，即典型的请求-应答模式。

### 缺点

该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就死掉了

### 改进

为了改进这种连接-线程的模型，我们可以使用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型，（但是其底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型‘，我们知道，如果使用CachedThreadPool线程池，其实除了能自动帮我们管理线程（复用），看起来也就像是1:1客户端：线程数模型，而是用FixedThreadPool我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步I/O模型，但是正因为限制了线程数量，如果发生读取数据较慢时（比如数据量大，网络传输慢等），大并发量的情况下，其他接入的信息，只能一直等待，这就是最大的弊端。

### 实战演练





