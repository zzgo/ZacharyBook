分布式锁和事务实战

引言

为什么要使用锁？

单机里面，可以完美的解决锁和事务

锁的场景

> 多任务环境下，多对一的资源访问
>
> 有状态的资源，会出现不一样的结果（有状态类）

问题本质

> 状态的变迁，需要时间，存在中间态
>
> 在1+1+1=3还未得出结果前，状态还是1，但只是幻象
>
> 其他任务出幻象值1，是错误的结果

明确一个信息

> 并不是所有的线程资源，都无法同时服务多个线程，比如无状态的资源
>
> 无成员变量或者成员变量不存在变化的类，就是无状态类，这种类是线程安全的
>
> 有状态的类也不一定是不安全的，前提：如果状态变化是原子的（即使没有中间变迁过程，变化不需要时间，没有中间态，一样是线程安全的）
>
> 重要的一个概念：动作的原子性
>
> 锁要解决的问题是： 资源数据会不一致
>
> 锁要达成的目标是 ：让资源使用起来，像原子性一样
>
> 锁达成目标的手段：让使用者访问资源时，只能排队，一个一个地去访问资源

锁的思路

> 对资源的访问进行排它处理
>
> 1+1+1=3得出结果之前，不允许别人染指
>
> 所有任务必须有序过独木桥

步骤

> 通过竞争获取锁（①竞争锁-排队）
>
> 任务在对资源操作中（②占有锁-占坑）
>
> 其他任务等待（③任务阻塞）
>
> 直到该任务完成（④释放锁）

目的

> 多个外部线程同时来竞争使用统一资源时，会彼此影响，导致混乱
>
> 将资源的使用做排它性处理，使同一时间，仅一个线程能访问资源

在单机应用里，JVM可以通过以下工具，可协调资源像原子性一样操作

> sychronized： java语言天生支持
>
> lock：jdk有接口标准

分布式锁方案

分布环境下，锁是脱离jvm控制的

分布式环境下，如何协调资源达到原子性的操作？

> sychronized / lock 这些java天然的实现，无法跨JVM发挥作用
>
> 只得去寻求分布式环境里，大家都公认的服务来做见证人，以协调资源
>
> 常见的公证人 ------》 mysql/zk/file/redis



